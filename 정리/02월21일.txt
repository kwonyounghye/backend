상속: 코드 재사용
상위 클래스 1개만 사용 가능
class 하위 extends 상위{
}

override
over+ride: 함수의 재정의
상위클래스의 함수를 재정의하는 것
@...=>annotation어노테이션
코드에 대한 도움말

final변수=>수정금지
final 함수=>오버라이드 금지
final 클래스=>상속 금지

->final이 붙으면 변경x

static member
인스턴스를 만들지 않고 사용 가능
non-static member
new 자료형( );
인스턴스를 만든 후 사용 가능

다형성
상위클래스 자료형으로 다양한 하위클래스 호출
좌변 상위=우변 하위( );

add unimplemented methods
추가  구현되지  않은  메소드

make type....abstract
현재 클래스를 추상클래스로

추상화: 공통적인 속성, 기능을 추출하는 작업
추상클래스: 일부 추상함수
인터페이스: 모두 추상함수
사용하는 목적: 코드를 표준화시키기 위하여
class 하위클래스 extends 상위클래스 implements 인터페이스
                                   1개                      여러개 가능

object: 모든 클래스의 기본 클래스
모든 자료형을 처리할 수 있음

str
참조변수
str+="programming";
str==>java /programming
인덱스01234/

object 모든 클래스의 기본 자료형
String final char 배열, 원본이 바뀌지 않음
StringBuilder: 원본을 변경
Wrapper class: 기본자료형의 다양한 연산을 지원하는 클래스
Math: 수학 계산 함수 지원


Math.random 0.0~1.0 난수 발생

클래스 이름과 같은 함수 - 생성자
변수에 대한 초기화 작업
this현재 instance의 시작, this 위로 전달함

ex0 Ex02 e= new Ex02( );-> Ex02(int a, int b) {
this.a=a;
this.b=b;}->생성자를 만들면 기본 생성자가 사라짐
->Ex02(){}

private가 붙으면 그 클래스에서만 사용할 수 있고 다른곳에선 사용 못함, 함수를 통해서만 사용 가능
ex) private int a;->e.setA(10);
int a->e.a=10; 

inerface 전체 추상
abstract 일부 추상

static변수, 함수==>프로그램 시작~끝(계속 고정되있음-정적인)
non-static, instance인스턴스==>new 생성, delete 삭제
                                                         개발자x

상위 클래스 static(o)->하위 클래스 method( );
상위 클래스 static(x)->하위 클래스 ex.method1=new method1( );....?

복잡할 때 StringBuilder가 효과적

@ annotation 어노케이션 코드에 대한 도움말
over ride 덮어쓰다 함수 치환 
ex)
ch12.Member@3d012ddd 해시코드
F3소스코드보기, F4계층구조 보기
@Override원래 클래스에 있던 것을 내려받아서 고친 것

Math.random( ) 0.0~1.0미만 범위
static이 아닌 건 new해야함

상속: 코드 재사용, expends
static:곧바로 사용
final: 
다형성: 좌변 상위, 우변 하위
추상화: 인터페이ㅡ implements
object: 모든 클래스의 상위 클래스
String/StringBuilder: 스트링 불변
Math
Wrapper: 기본자료형에 대한 다양한 함수 제공